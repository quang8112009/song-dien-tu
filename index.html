<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vật Lý Trực Quan: Phản Xạ Tầng Điện Ly</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { background-color: #020617; color: #f8fafc; font-family: 'Segoe UI', sans-serif; overflow-x: hidden; scroll-behavior: smooth; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
        #particle-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none; background: radial-gradient(circle at center, #1e293b 0%, #020617 100%); }
        .glass-panel { background: rgba(30, 41, 59, 0.6); backdrop-filter: blur(12px); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 1rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease; }
        .glass-panel:hover { border-color: rgba(148, 163, 184, 0.3); }
        .canvas-container { position: relative; width: 100%; height: 75vh; min-height: 550px; background: rgba(2, 6, 23, 0.3); border-radius: 1rem; overflow: hidden; border: 1px solid rgba(51, 65, 85, 0.5); box-shadow: inset 0 0 50px rgba(0,0,0,0.6); }
        .controls-overlay { position: absolute; top: 20px; left: 20px; width: 300px; padding: 1.5rem; z-index: 20; background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(15px); border: 1px solid rgba(71, 85, 105, 0.5); border-radius: 1rem; transition: transform 0.4s ease, opacity 0.4s; }
        .controls-overlay.hidden-ui { transform: translateX(-350px); opacity: 0; pointer-events: none; }
        .subtitle-box { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%) translateY(30px); background: rgba(0, 0, 0, 0.85); color: #fbbf24; padding: 15px 30px; border-radius: 50px; font-size: 1.1rem; font-weight: 500; text-align: center; border: 1px solid rgba(255, 255, 255, 0.15); width: 90%; max-width: 800px; opacity: 0; pointer-events: none; z-index: 30; transition: all 0.5s ease; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .subtitle-box.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        .stop-btn { position: absolute; top: 20px; right: 20px; background: rgba(239, 68, 68, 0.9); color: white; padding: 10px 20px; border-radius: 30px; font-weight: bold; cursor: pointer; display: none; z-index: 40; box-shadow: 0 0 20px rgba(239, 68, 68, 0.4); border: 1px solid rgba(255,255,255,0.2); animation: pulse-red 2s infinite; }
        .stop-btn:hover { transform: scale(1.05); }
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }
        input[type=range] { -webkit-appearance: none; background: transparent; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; margin-top: -6px; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #334155; border-radius: 2px; }
        .label-marker { background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; white-space: nowrap; border: 1px solid rgba(255,255,255,0.2); }
    </style>
</head>
<body>

    <canvas id="particle-bg"></canvas>

    <nav class="sticky top-0 z-50 bg-slate-900/80 backdrop-blur-md border-b border-slate-700/50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white shadow-lg"><i class="fa-solid fa-atom"></i></div>
                    <span class="font-bold text-xl text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-white">Vật Lý Trực Quan</span>
                </div>
                <div class="hidden md:flex space-x-8 text-sm font-medium">
                    <a href="#section-wave" class="text-slate-300 hover:text-white hover:border-b-2 border-blue-500 transition-all py-1">Mô hình Sóng</a>
                    <a href="#section-antenna" class="text-slate-300 hover:text-white hover:border-b-2 border-emerald-500 transition-all py-1">Đài Phát Thanh</a>
                    <a href="#section-iono" class="text-slate-300 hover:text-white hover:border-b-2 border-indigo-500 transition-all py-1">Tầng Điện Ly</a>
                </div>
            </div>
        </div>
    </nav>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 space-y-32">
        
        <!-- SECTION 1: EM WAVE (Giữ nguyên) -->
        <section id="section-wave" class="pt-6">
            <div class="text-center mb-10">
                <h1 class="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 mb-4 drop-shadow-lg">1. Bản Chất Sóng Điện Từ</h1>
                <p class="text-slate-300 max-w-2xl mx-auto">Mô phỏng chi tiết các vectơ cường độ Điện trường (E) và cảm ứng Từ trường (B).</p>
            </div>
            <div class="glass-panel p-1 relative shadow-2xl mb-12">
                <div id="canvas-wave" class="canvas-container">
                    <div id="sub-wave" class="subtitle-box">...</div>
                    <button id="stop-wave" class="stop-btn"><i class="fas fa-stop mr-2"></i>Dừng Phim</button>
                    <div id="ctrl-wave" class="controls-overlay">
                        <div class="flex justify-between items-center mb-6 border-b border-slate-600 pb-3">
                            <h3 class="font-bold text-blue-100 text-sm uppercase">Cấu Trúc Sóng</h3>
                            <button id="reset-wave" class="text-xs text-slate-400 hover:text-white"><i class="fas fa-sync-alt mr-1"></i> Reset</button>
                        </div>
                        <button id="play-wave" class="w-full mb-6 bg-gradient-to-r from-indigo-600 to-purple-600 text-white py-3 rounded-xl shadow-lg font-bold hover:scale-[1.02] transition border border-white/20"><i class="fas fa-play-circle mr-2"></i> Video Giới Thiệu</button>
                        <div class="space-y-4">
                            <div><label class="flex justify-between text-xs text-slate-300 mb-2"><span>Tốc độ</span><span id="val-speed">50%</span></label><input type="range" id="inp-speed" min="0" max="0.2" step="0.01" value="0.05" class="w-full"></div>
                            <label class="flex items-center justify-between cursor-pointer p-2 rounded hover:bg-white/5 transition"><span class="text-sm text-red-400"><i class="fas fa-bolt mr-2 w-5"></i>Điện trường (E)</span><input type="checkbox" id="chk-e" checked class="accent-red-500"></label>
                            <label class="flex items-center justify-between cursor-pointer p-2 rounded hover:bg-white/5 transition"><span class="text-sm text-blue-400"><i class="fas fa-magnet mr-2 w-5"></i>Từ trường (B)</span><input type="checkbox" id="chk-b" checked class="accent-blue-500"></label>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- SECTION 2: RADIO BROADCASTING (Giữ nguyên) -->
        <section id="section-antenna" class="pt-6">
            <div class="text-center mb-10">
                <h1 class="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-emerald-400 to-teal-500 mb-4 drop-shadow-lg">2. Đài Phát Thanh Vô Tuyến</h1>
                <p class="text-slate-300 max-w-2xl mx-auto">Mô phỏng quá trình truyền tín hiệu từ tháp phát sóng đến máy thu thanh (Radio).</p>
            </div>
            <div class="glass-panel p-1 relative shadow-2xl mb-12">
                <div id="canvas-ant" class="canvas-container">
                    <div id="sub-ant" class="subtitle-box">...</div>
                    <button id="stop-ant" class="stop-btn"><i class="fas fa-stop mr-2"></i>Dừng Phim</button>
                    <div id="ctrl-ant" class="controls-overlay">
                        <div class="flex justify-between items-center mb-6 border-b border-slate-600 pb-3">
                            <h3 class="font-bold text-teal-100 text-sm uppercase">Trạm Phát Sóng</h3>
                            <button id="reset-ant" class="text-xs text-slate-400 hover:text-white"><i class="fas fa-sync-alt mr-1"></i> Reset</button>
                        </div>
                        <button id="play-ant" class="w-full mb-6 bg-gradient-to-r from-teal-600 to-green-600 text-white py-3 rounded-xl shadow-lg font-bold hover:scale-[1.02] transition border border-white/20"><i class="fas fa-broadcast-tower mr-2"></i> Video Mô Phỏng</button>
                        <div class="space-y-5">
                            <div>
                                <label class="flex justify-between text-xs text-slate-300 mb-2"><span>Khoảng cách (Rx)</span><span id="val-dist" class="text-teal-400">Gần</span></label>
                                <input type="range" id="inp-dist" min="5" max="25" step="0.1" value="10" class="w-full">
                                <p class="text-[10px] text-slate-500 mt-1 italic">*Kéo ra xa tín hiệu yếu dần</p>
                            </div>
                            <div class="flex items-center justify-between p-2 rounded hover:bg-white/5 transition">
                                <span class="text-sm text-slate-300">Hiển thị sóng</span>
                                <input type="checkbox" id="chk-wave" checked class="accent-teal-500 w-4 h-4">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- SECTION 3: IONOSPHERE REFLECTION (NEW SPHERICAL VIEW) -->
        <section id="section-iono" class="pt-6 pb-20">
            <div class="text-center mb-10">
                <h1 class="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-blue-600 mb-4 drop-shadow-lg">
                    3. Phản Xạ Tầng Điện Ly
                </h1>
                <p class="text-slate-300 max-w-2xl mx-auto">Mô phỏng đường truyền "zíc-zắc" của sóng vô tuyến ngắn (Skywave) quanh quả cầu Trái Đất.</p>
            </div>

            <div class="glass-panel p-1 relative shadow-2xl mb-12">
                <div id="canvas-iono" class="canvas-container">
                    <div id="sub-iono" class="subtitle-box">...</div>
                    <button id="stop-iono" class="stop-btn"><i class="fas fa-stop mr-2"></i>Dừng Phim</button>

                    <div id="ctrl-iono" class="controls-overlay">
                        <div class="flex justify-between items-center mb-6 border-b border-slate-600 pb-3">
                            <h3 class="font-bold text-indigo-100 text-sm uppercase">Thông Số Môi Trường</h3>
                            <button id="reset-iono" class="text-xs text-slate-400 hover:text-white"><i class="fas fa-sync-alt mr-1"></i> Reset</button>
                        </div>
                        <button id="play-iono" class="w-full mb-6 bg-gradient-to-r from-indigo-600 to-blue-600 text-white py-3 rounded-xl shadow-lg font-bold hover:scale-[1.02] transition border border-white/20"><i class="fas fa-globe-americas mr-2"></i> Giải Thích Quy Trình</button>
                        <div class="space-y-5">
                            <div>
                                <label class="flex justify-between text-xs text-slate-300 mb-2"><span>Độ cao tầng điện ly</span></label>
                                <input type="range" id="inp-iono-h" min="65" max="85" step="1" value="75" class="w-full">
                            </div>
                            <div class="flex items-center justify-between p-2 rounded hover:bg-white/5 transition">
                                <span class="text-sm text-yellow-400 font-bold">Hiện đường đi sóng</span>
                                <input type="checkbox" id="chk-path" checked class="accent-yellow-500 w-4 h-4">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Theory -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="glass-panel p-8">
                    <div class="flex items-center mb-4 text-indigo-400">
                        <i class="fas fa-layer-group text-2xl mr-3"></i>
                        <h3 class="text-xl font-bold text-white">Tầng Điện Ly Là Gì?</h3>
                    </div>
                    <p class="text-slate-300 mb-4 text-justify leading-7">
                        Là một lớp khí quyển bị ion hóa bởi bức xạ mặt trời, nằm ở độ cao từ 60km đến 1000km. Nó có khả năng phản xạ sóng vô tuyến ngắn (HF) trở lại Trái Đất như một tấm gương khổng lồ.
                    </p>
                </div>
                <div class="glass-panel p-8">
                    <div class="flex items-center mb-4 text-blue-400">
                        <i class="fas fa-wave-square text-2xl mr-3"></i>
                        <h3 class="text-xl font-bold text-white">Truyền Sóng Trời (Skywave)</h3>
                    </div>
                    <p class="text-slate-300 text-sm text-justify leading-7">
                        Nhờ phản xạ liên tiếp giữa tầng điện ly và mặt đất (hoặc mặt biển), sóng vô tuyến có thể truyền đi rất xa, vượt qua độ cong của Trái Đất để đến được máy thu ở bên kia bán cầu.
                    </p>
                </div>
            </div>
        </section>

    </main>

    <footer class="border-t border-slate-800 bg-slate-900/80 py-8 text-center text-slate-500 text-sm mt-12">
        &copy; 2023 Physics Viz Project. Built with Three.js
    </footer>

    <!-- SCRIPTS -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- BACKGROUND PARTICLES ---
        (function() {
            const canvas = document.getElementById('particle-bg');
            const ctx = canvas.getContext('2d');
            let w, h, mols = [];
            function resize() { w=canvas.width=window.innerWidth; h=canvas.height=window.innerHeight; }
            class Mol {
                constructor() { this.init(); }
                init() { this.x=Math.random()*w; this.y=Math.random()*h; this.vx=(Math.random()-0.5)*0.5; this.vy=(Math.random()-0.5)*0.5; this.size=Math.random()*2+2; this.op=Math.random()*0.3+0.1; }
                update() { this.x+=this.vx; this.y+=this.vy; if(this.x<0||this.x>w||this.y<0||this.y>h) this.init(); }
                draw() { 
                    ctx.fillStyle=`rgba(148,163,184,${this.op})`; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x+this.size*1.5,this.y,this.size*0.7,0,Math.PI*2); ctx.fill();
                }
            }
            function loop() { ctx.clearRect(0,0,w,h); mols.forEach(m=>{m.update(); m.draw()}); requestAnimationFrame(loop); }
            window.addEventListener('resize', resize); resize(); for(let i=0;i<40;i++) mols.push(new Mol()); loop();
        })();

        // --- WAVE SIMULATION ---
        class WaveSim {
            constructor() {
                this.conf = { len: 50, pts: 200, amp: 3, spd: 0.05, lambda: 10 };
                this.time = 0; this.cine = false;
                this.init();
            }
            init() {
                const con = document.getElementById('canvas-wave');
                this.scene = new THREE.Scene();
                this.cam = new THREE.PerspectiveCamera(45, con.clientWidth/con.clientHeight, 0.1, 1000);
                this.cam.position.set(25, 20, 45);
                this.ren = new THREE.WebGLRenderer({antialias:true, alpha:true});
                this.ren.setSize(con.clientWidth, con.clientHeight);
                this.ren.setPixelRatio(window.devicePixelRatio);
                con.appendChild(this.ren.domElement);
                this.ctrl = new OrbitControls(this.cam, this.ren.domElement);
                this.ctrl.enableDamping=true;

                this.scene.add(new THREE.GridHelper(60,60,0x475569,0x1e293b));
                const zAx = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,-this.conf.len), new THREE.Vector3(0,0,this.conf.len)]), new THREE.LineBasicMaterial({color:0xfacc15, linewidth:2, transparent: true, opacity: 0.3}));
                // removed zAx add
                // this.scene.add(zAx);

                this.buildWaves();
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                const dl = new THREE.DirectionalLight(0xffffff, 1.5); dl.position.set(10, 20, 10); this.scene.add(dl);

                this.bindUI();
                this.loop();
                window.addEventListener('resize', ()=>{
                    this.cam.aspect=con.clientWidth/con.clientHeight; this.cam.updateProjectionMatrix(); this.ren.setSize(con.clientWidth, con.clientHeight);
                });
            }

            buildWaves() {
                this.gE = new THREE.Group(); this.gB = new THREE.Group(); this.scene.add(this.gE); this.scene.add(this.gB);
                const pts = new Float32Array(this.conf.pts*3);
                this.eC = new THREE.Line(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(pts, 3)), new THREE.LineBasicMaterial({color:0xf87171, linewidth:3}));
                this.bC = new THREE.Line(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.conf.pts*3), 3)), new THREE.LineBasicMaterial({color:0x60a5fa, linewidth:3}));
                this.gE.add(this.eC); this.gB.add(this.bC);
                
                this.eVs=[]; this.bVs=[];
                this.eLabel = this.createLabel("E", "#f87171");
                this.bLabel = this.createLabel("B", "#60a5fa");
                this.gE.add(this.eLabel); this.gB.add(this.bLabel);

                const dirE = new THREE.Vector3(0, 1, 0); const dirB = new THREE.Vector3(1, 0, 0);
                const origin = new THREE.Vector3(0, 0, 0); const length = 1;
                const hexE = 0xf87171; const hexB = 0x60a5fa;

                for(let i=0; i<this.conf.pts; i+=4) {
                    let arrowE = new THREE.ArrowHelper(dirE, origin, length, hexE, 0.5, 0.3);
                    let arrowB = new THREE.ArrowHelper(dirB, origin, length, hexB, 0.5, 0.3);
                    this.gE.add(arrowE); this.gB.add(arrowB);
                    this.eVs.push(arrowE); this.bVs.push(arrowB);
                }
            }

            createLabel(text, colorStr) {
                const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d'); ctx.font = "bold 48px Arial"; ctx.fillStyle = colorStr; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(text, 32, 32);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false })); sprite.scale.set(2, 2, 1); return sprite;
            }

            bindUI() {
                this.ui = { spd: document.getElementById('inp-speed'), txtS: document.getElementById('val-speed'), chkE: document.getElementById('chk-e'), chkB: document.getElementById('chk-b'), pan: document.getElementById('ctrl-wave'), sub: document.getElementById('sub-wave'), stop: document.getElementById('stop-wave') };
                this.ui.spd.oninput = (e)=> this.ui.txtS.innerText=Math.round(e.target.value/0.2*100)+'%';
                document.getElementById('reset-wave').onclick = ()=> { this.cam.position.set(25,20,45); this.ctrl.target.set(0,0,0); };
                document.getElementById('play-wave').onclick = ()=> this.startCine();
                this.ui.stop.onclick = ()=> this.stopCine();
            }
            startCine() { this.cine=true; this.cStart=Date.now(); this.ui.pan.classList.add('hidden-ui'); this.ui.sub.classList.add('visible'); this.ui.stop.style.display='block'; this.ctrl.enabled=false; }
            stopCine() { this.cine=false; this.ui.pan.classList.remove('hidden-ui'); this.ui.sub.classList.remove('visible'); this.ui.stop.style.display='none'; this.ctrl.enabled=true; this.cam.position.set(25,20,45); this.cam.lookAt(0,0,0); }
            
            update() {
                let s = parseFloat(this.ui.spd.value); if(this.cine) s=0.05;
                this.time += s;
                this.gE.visible = this.cine || this.ui.chkE.checked; this.gB.visible = this.cine || this.ui.chkB.checked;
                
                const posE = this.eC.geometry.attributes.position.array; const posB = this.bC.geometry.attributes.position.array; const k = (2*Math.PI)/this.conf.lambda;
                let vI=0;
                for(let i=0; i<this.conf.pts; i++) {
                    const z = (i/(this.conf.pts-1))*this.conf.len - this.conf.len/2; const val = this.conf.amp * Math.sin(k*z - this.time);
                    posE[i*3]=0; posE[i*3+1]=val; posE[i*3+2]=z; posB[i*3]=val; posB[i*3+1]=0; posB[i*3+2]=z;
                    if (i > this.conf.pts/2 && val > 2.8 && z < 10) { this.eLabel.position.set(0, val + 1.5, z); this.bLabel.position.set(val + 1.5, 0, z); }
                }
                for(let i=0; i<this.conf.pts; i+=4) {
                    if (vI < this.eVs.length) {
                        const z = (i/(this.conf.pts-1))*this.conf.len - this.conf.len/2; const val = this.conf.amp * Math.sin(k*z - this.time);
                        this.eVs[vI].visible = this.gE.visible; this.eVs[vI].position.set(0, 0, z);
                        if (Math.abs(val) > 0.1) { this.eVs[vI].setLength(Math.abs(val), 0.5, 0.3); this.eVs[vI].setDirection(new THREE.Vector3(0, Math.sign(val), 0)); } else this.eVs[vI].visible = false;
                        this.bVs[vI].visible = this.gB.visible; this.bVs[vI].position.set(0, 0, z);
                        if (Math.abs(val) > 0.1) { this.bVs[vI].setLength(Math.abs(val), 0.5, 0.3); this.bVs[vI].setDirection(new THREE.Vector3(Math.sign(val), 0, 0)); } else this.bVs[vI].visible = false;
                        vI++;
                    }
                }
                this.eC.geometry.attributes.position.needsUpdate=true; this.bC.geometry.attributes.position.needsUpdate=true;
                if(this.cine) {
                    const el = (Date.now()-this.cStart)/1000; let txt="";
                    if(el<5) txt="Đây là mô hình Sóng Điện Từ lan truyền trong không gian.";
                    else if(el<10) txt="Hai thành phần chính: Điện trường (Đỏ) và Từ trường (Xanh).";
                    else if(el<15) txt="Chúng luôn vuông góc với nhau và vuông góc với phương truyền.";
                    else if(el<20) txt="Tại mọi điểm, chúng dao động cùng pha (cùng đạt cực đại hoặc bằng 0)."; else { this.stopCine(); return; }
                    this.ui.sub.innerText=txt; const a = el*0.3; this.cam.position.set(Math.sin(a)*35, 15+Math.sin(el)*5, Math.cos(a)*35); this.cam.lookAt(0,0,0);
                } else this.ctrl.update();
            }
            loop() { requestAnimationFrame(()=>this.loop()); this.update(); this.ren.render(this.scene, this.cam); }
        }

        // --- CLASS: RADIO BROADCASTING ---
        class AntSim {
            constructor() { this.waves=[]; this.time=0; this.cine=false; this.init(); }
            init() {
                const con = document.getElementById('canvas-ant');
                this.scene = new THREE.Scene();
                this.cam = new THREE.PerspectiveCamera(50, con.clientWidth/con.clientHeight, 0.1, 100);
                this.cam.position.set(0, 25, 45); 
                this.ren = new THREE.WebGLRenderer({antialias:true, alpha:true});
                this.ren.setSize(con.clientWidth, con.clientHeight);
                this.ren.shadowMap.enabled=true;
                con.appendChild(this.ren.domElement);
                this.ctrl = new OrbitControls(this.cam, this.ren.domElement); this.ctrl.enableDamping=true;
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const dl = new THREE.DirectionalLight(0xffffff, 1); dl.position.set(10,30,20); dl.castShadow=true; this.scene.add(dl);
                this.buildLab(); this.bindUI(); this.loop();
                window.addEventListener('resize', ()=>{
                    this.cam.aspect=con.clientWidth/con.clientHeight; this.cam.updateProjectionMatrix(); this.ren.setSize(con.clientWidth, con.clientHeight);
                });
            }

            buildLab() {
                const ground = new THREE.Mesh(new THREE.CircleGeometry(60, 64), new THREE.MeshStandardMaterial({color: 0x1e293b, roughness: 0.8})); 
                ground.rotation.x = -Math.PI/2; ground.position.y = -0.1; ground.receiveShadow = true; this.scene.add(ground);
                const grid = new THREE.GridHelper(100, 50, 0x334155, 0x0f172a); this.scene.add(grid);

                const steel = new THREE.MeshStandardMaterial({color:0x94a3b8, metalness:0.6, roughness:0.4});
                const redPaint = new THREE.MeshStandardMaterial({color:0xef4444});
                const wood = new THREE.MeshStandardMaterial({color:0x854d0e});

                this.tx = new THREE.Group();
                const legGeo = new THREE.CylinderGeometry(0.1, 0.4, 20);
                const l1 = new THREE.Mesh(legGeo, steel); l1.position.set(-2, 10, -2); l1.rotation.x=0.1; l1.rotation.z=-0.1;
                const l2 = new THREE.Mesh(legGeo, steel); l2.position.set(2, 10, -2); l2.rotation.x=0.1; l2.rotation.z=0.1;
                const l3 = new THREE.Mesh(legGeo, steel); l3.position.set(2, 10, 2); l3.rotation.x=-0.1; l3.rotation.z=0.1;
                const l4 = new THREE.Mesh(legGeo, steel); l4.position.set(-2, 10, 2); l4.rotation.x=-0.1; l4.rotation.z=-0.1;
                const cross1 = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.2, 0.2), steel); cross1.position.y=5;
                const cross2 = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.2, 0.2), steel); cross2.position.y=10;
                const cross3 = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.2, 0.2), steel); cross3.position.y=15;
                const spire = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.1, 5), redPaint); spire.position.y=22.5;
                const axesHelper = new THREE.AxesHelper(5); axesHelper.position.y = 20; 
                this.beacon = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xff0000}));
                this.beacon.position.y=25;
                this.tx.add(l1,l2,l3,l4, cross1, cross2, cross3, spire, this.beacon, axesHelper);
                this.tx.position.set(-15, 0, 0); this.scene.add(this.tx); this.label(this.tx, "Tháp Phát Sóng", 27);

                this.rx = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(4, 2.5, 1.5), wood); body.position.y=1.25; body.castShadow=true;
                const spk = new THREE.Mesh(new THREE.CircleGeometry(0.8, 32), new THREE.MeshStandardMaterial({color:0x333333})); spk.position.set(-1, 1.25, 0.76); 
                const dial = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 0.1), new THREE.MeshStandardMaterial({color:0xfcd34d})); dial.position.set(1, 1.8, 0.76);
                const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 3), steel); ant.position.set(1.8, 2.5, -0.5); ant.rotation.z = 0.2;
                const meterBg = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.3), new THREE.MeshBasicMaterial({color:0x000000})); meterBg.position.set(1, 1, 0.77);
                this.meterBar = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 0.2), new THREE.MeshBasicMaterial({color:0x22c55e}));
                this.meterBar.geometry.translate(0.7, 0, 0); this.meterBar.position.set(0.3, 1, 0.78); this.meterBar.scale.x = 0.1;
                this.rx.add(body, spk, dial, ant, meterBg, this.meterBar);
                this.rx.position.set(10, 0, 0); this.scene.add(this.rx); this.label(this.rx, "Đài Radio", 5);

                for(let i=0; i<15; i++){
                    const m = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.5), 
                                           new THREE.MeshBasicMaterial({color:0x2dd4bf, transparent:true, opacity:0, side:THREE.DoubleSide, wireframe: false}));
                    m.rotation.x = -Math.PI/2; m.position.set(-15, 25, 0); m.visible=false; m.userData={act:false, age:0};
                    this.scene.add(m); this.waves.push(m);
                }
            }
            label(p,t,y) { const c=document.createElement('canvas'); c.width=256; c.height=64; const ctx=c.getContext('2d'); ctx.font="bold 30px Arial"; ctx.fillStyle="white"; ctx.textAlign="center"; ctx.fillText(t,128,40); const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c)})); s.position.y=y; s.scale.set(6,1.5,1); p.add(s); }
            bindUI() {
                this.ui = { dist: document.getElementById('inp-dist'), valD: document.getElementById('val-dist'), chkW: document.getElementById('chk-wave'), pan: document.getElementById('ctrl-ant'), sub: document.getElementById('sub-ant'), stop: document.getElementById('stop-ant') };
                document.getElementById('reset-ant').onclick = ()=> { this.cam.position.set(0,25,45); this.ctrl.target.set(0,10,0); };
                document.getElementById('play-ant').onclick = ()=> this.startCine(); this.ui.stop.onclick = ()=> this.stopCine();
            }
            startCine() { this.cine=true; this.cStart=Date.now(); this.ui.pan.classList.add('hidden-ui'); this.ui.sub.classList.add('visible'); this.ui.stop.style.display='block'; this.ctrl.enabled=false; this.rx.position.x=0; }
            stopCine() { this.cine=false; this.ui.pan.classList.remove('hidden-ui'); this.ui.sub.classList.remove('visible'); this.ui.stop.style.display='none'; this.ctrl.enabled=true; this.cam.position.set(0,25,45); this.cam.lookAt(0,10,0); }
            
            update() {
                let d = parseFloat(this.ui.dist.value); if(this.cine) d=15;
                this.rx.position.x = -15 + d + 5;
                this.time += 0.05;
                if(Math.floor(this.time*5)%2===0) this.beacon.material.color.setHex(0xff0000); else this.beacon.material.color.setHex(0x500000);
                if(Math.floor(this.time*20)%20===0) { const w=this.waves.find(x=>!x.userData.act); if(w) { w.userData.act=true; w.userData.age=0; w.scale.set(1,1,1); w.material.opacity=0.6; w.visible=this.ui.chkW.checked; } }
                this.waves.forEach(w=>{
                    if(w.userData.act) { w.userData.age+=0.05; const s=1+w.userData.age*8; w.scale.set(s,s,s); w.material.opacity=Math.max(0, 0.6-w.userData.age/3); if(w.material.opacity<=0) { w.userData.act=false; w.visible=false; } }
                });
                const dist = Math.abs(this.rx.position.x - this.tx.position.x);
                let signal = Math.min(Math.max(200/(dist*dist), 0.1), 1);
                this.meterBar.scale.x = signal; this.meterBar.material.color.setHSL(signal * 0.3, 1, 0.5);
                if(!this.cine) { if(dist<15) this.ui.valD.innerText="Mạnh (Gần)"; else if(dist<30) this.ui.valD.innerText="Trung Bình"; else this.ui.valD.innerText="Yếu (Xa)"; }
                if(this.cine) {
                    const el = (Date.now()-this.cStart)/1000; let txt="";
                    if(el<5) { txt="Đây là tháp truyền thanh. Tín hiệu được phát từ đỉnh tháp."; this.cam.position.lerp(new THREE.Vector3(-15, 25, 20), 0.05); this.ctrl.target.lerp(new THREE.Vector3(-15, 20, 0), 0.05); }
                    else if(el<10) { txt="Sóng vô tuyến lan truyền ra không gian theo mọi hướng."; this.cam.position.lerp(new THREE.Vector3(0, 40, 60), 0.05); this.ctrl.target.lerp(new THREE.Vector3(0, 10, 0), 0.05); }
                    else if(el<16) { txt="Đài Radio thu sóng. Hãy nhìn thanh tín hiệu màu xanh trên mặt đài."; this.rx.position.x = -15 + (el-8)*3; this.cam.position.lerp(new THREE.Vector3(this.rx.position.x+5, 5, 10), 0.05); this.ctrl.target.lerp(this.rx.position, 0.05); }
                    else if(el<20) { txt="Khi đi xa khỏi tháp, tín hiệu yếu dần và thanh đo giảm xuống."; this.cam.position.lerp(new THREE.Vector3(0, 20, 50), 0.05); }
                    else { this.stopCine(); return; } this.ui.sub.innerText=txt;
                } else this.ctrl.update();
            }
            loop() { requestAnimationFrame(()=>this.loop()); this.update(); this.ren.render(this.scene, this.cam); }
        }

        // --- CLASS: IONOSPHERE PROPAGATION (UPDATED SPHERE) ---
        class IonoSim {
            constructor() { this.time=0; this.cine=false; this.init(); }
            init() {
                const con = document.getElementById('canvas-iono');
                this.scene = new THREE.Scene();
                this.cam = new THREE.PerspectiveCamera(45, con.clientWidth/con.clientHeight, 0.1, 1000);
                this.cam.position.set(0, 60, 100); 
                this.ren = new THREE.WebGLRenderer({antialias:true, alpha:true});
                this.ren.setSize(con.clientWidth, con.clientHeight);
                con.appendChild(this.ren.domElement);
                this.ctrl = new OrbitControls(this.cam, this.ren.domElement); this.ctrl.enableDamping=true;
                
                const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(0, 100, 50); this.scene.add(sun);
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.3));

                this.buildWorld(); this.bindUI(); this.loop();
                window.addEventListener('resize', ()=>{ this.cam.aspect=con.clientWidth/con.clientHeight; this.cam.updateProjectionMatrix(); this.ren.setSize(con.clientWidth, con.clientHeight); });
            }

            buildWorld() {
                // Constants
                this.R_EARTH = 60; 
                this.R_IONO = 75;

                // Earth - Full Sphere
                const earthGeo = new THREE.SphereGeometry(this.R_EARTH, 64, 64);
                const earthMat = new THREE.MeshPhongMaterial({color: 0x1e3a8a, emissive: 0x050510, specular: 0x222222});
                this.earth = new THREE.Mesh(earthGeo, earthMat);
                // Wireframe
                const wGeo = new THREE.WireframeGeometry(earthGeo);
                const wMat = new THREE.LineBasicMaterial({color: 0x3b82f6, transparent: true, opacity: 0.2});
                this.earth.add(new THREE.LineSegments(wGeo, wMat));
                this.scene.add(this.earth);

                // Ionosphere - Full Sphere
                const ionoGeo = new THREE.SphereGeometry(this.R_IONO, 64, 64);
                const ionoMat = new THREE.MeshBasicMaterial({color: 0x22d3ee, transparent: true, opacity: 0.15, side: THREE.DoubleSide, depthWrite: false});
                this.iono = new THREE.Mesh(ionoGeo, ionoMat);
                this.scene.add(this.iono);

                // Stations (Tx Left, Rx Right)
                const angle = 0.5; // rad offset from top center
                this.txPos = this.getSpherePos(this.R_EARTH, -angle);
                this.rxPos = this.getSpherePos(this.R_EARTH, angle);

                // Place stations correctly on sphere surface (Y-up sphere)
                this.tx = this.createStation(0xffaa00); 
                this.tx.position.copy(this.txPos); 
                // Align orientation: Up vector should be normal to sphere surface
                this.tx.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), this.txPos.clone().normalize());
                this.scene.add(this.tx); this.label(this.tx, "Anten", 5);

                this.rx = this.createStation(0x22c55e); 
                this.rx.position.copy(this.rxPos);
                this.rx.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), this.rxPos.clone().normalize());
                this.scene.add(this.rx); this.label(this.rx, "Máy thu", 5);

                // Label for Ionosphere
                const lIono = this.createLabel("Tầng điện ly");
                lIono.position.set(0, this.R_IONO + 2, 0);
                this.scene.add(lIono);

                // Path Calculation
                const aTx = -angle; 
                const aRx = angle;
                const aMid = 0;
                const aI1 = (aTx + aMid)/2;
                const aI2 = (aMid + aRx)/2;

                this.pathPoints = [
                    this.getSpherePos(this.R_EARTH, aTx),      // 0: Tx
                    this.getSpherePos(this.R_IONO, aI1),       // 1: Iono (Peak 1)
                    this.getSpherePos(this.R_EARTH, aMid),     // 2: Gnd bounce
                    this.getSpherePos(this.R_IONO, aI2),       // 3: Iono (Peak 2)
                    this.getSpherePos(this.R_EARTH, aRx)       // 4: Rx
                ];

                // --- ADD 2 SATELLITES AT PEAKS WITH LABELS ---
                this.sat1 = this.createSatellite();
                this.sat1.position.copy(this.pathPoints[1]);
                this.sat1.lookAt(0,0,0);
                this.scene.add(this.sat1);
                
                // Thêm nhãn cho Vệ tinh 1 (Đặt ở trục Z địa phương để hướng ra ngoài)
                const lblSat1 = this.createLabel("Vệ tinh 1");
                lblSat1.position.set(0, 3, 0); // Điều chỉnh vị trí nhãn cao lên một chút
                // Do vệ tinh dùng lookAt(0,0,0), trục +Z hướng ra xa tâm trái đất. 
                // Tuy nhiên, hình khối hộp vệ tinh có thể định hướng khác. 
                // Thử đặt vị trí (0, 3, 0) (trục Y vệ tinh) hoặc (0, 0, 3) (trục Z vệ tinh)
                lblSat1.position.set(0, 0, 4); 
                this.sat1.add(lblSat1);

                this.sat2 = this.createSatellite();
                this.sat2.position.copy(this.pathPoints[3]);
                this.sat2.lookAt(0,0,0);
                this.scene.add(this.sat2);
                
                // Thêm nhãn cho Vệ tinh 2
                const lblSat2 = this.createLabel("Vệ tinh 2");
                lblSat2.position.set(0, 0, 4);
                this.sat2.add(lblSat2);

                // Draw Path Lines
                const pathGeo = new THREE.BufferGeometry().setFromPoints(this.pathPoints);
                this.pathLine = new THREE.Line(pathGeo, new THREE.LineBasicMaterial({color: 0xffff00, opacity: 0.5, transparent: true}));
                this.scene.add(this.pathLine);

                this.pulses = [];
            }

            createSatellite() {
                const g = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshPhongMaterial({color: 0xeab308}));
                const panels = new THREE.Mesh(new THREE.BoxGeometry(6, 0.1, 1.5), new THREE.MeshPhongMaterial({color: 0x1d4ed8}));
                g.add(body, panels);
                return g;
            }

            getSpherePos(r, angle) {
                // Circle in XY plane, centered at 0,0,0. Top is (0, R, 0).
                // x = r * sin(angle), y = r * cos(angle)
                return new THREE.Vector3(r * Math.sin(angle), r * Math.cos(angle), 0);
            }

            createStation(color) {
                const g = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(2,4,2), new THREE.MeshPhongMaterial({color:color}));
                base.position.y=2;
                const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.2, 5), new THREE.MeshPhongMaterial({color:0x888888}));
                ant.position.y=6;
                g.add(base, ant);
                return g;
            }

            createLabel(txt) {
                const c=document.createElement('canvas'); c.width=256; c.height=64;
                const ctx=c.getContext('2d'); ctx.font="bold 40px Arial"; ctx.fillStyle="white"; ctx.textAlign="center"; ctx.fillText(txt,128,50);
                const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c)})); s.scale.set(10,2.5,1); return s;
            }
            label(p,t,y) { const s=this.createLabel(t); s.position.y=y; p.add(s); }

            bindUI() {
                this.ui = { 
                    h: document.getElementById('inp-iono-h'), chkPath: document.getElementById('chk-path'),
                    pan: document.getElementById('ctrl-iono'), sub: document.getElementById('sub-iono'), stop: document.getElementById('stop-iono')
                };
                document.getElementById('reset-iono').onclick = ()=> { this.cam.position.set(0,60,100); this.ctrl.target.set(0,50,0); };
                document.getElementById('play-iono').onclick = ()=> this.startCine();
                this.ui.stop.onclick = ()=> this.stopCine();
            }
            startCine() { this.cine=true; this.cStart=Date.now(); this.ui.pan.classList.add('hidden-ui'); this.ui.sub.classList.add('visible'); this.ui.stop.style.display='block'; this.ctrl.enabled=false; }
            stopCine() { this.cine=false; this.ui.pan.classList.remove('hidden-ui'); this.ui.sub.classList.remove('visible'); this.ui.stop.style.display='none'; this.ctrl.enabled=true; this.cam.position.set(0,60,100); this.cam.lookAt(0,50,0); }

            update() {
                let h = parseFloat(this.ui.h.value); 
                if(this.cine) h = 75;
                this.R_IONO = h;
                
                this.iono.scale.setScalar(h/75);

                const angle = 0.5;
                const aTx = -angle; const aRx = angle; const aMid = 0;
                const aI1 = (aTx + aMid)/2; const aI2 = (aMid + aRx)/2;
                
                this.pathPoints[1] = this.getSpherePos(h, aI1);
                this.pathPoints[3] = this.getSpherePos(h, aI2);
                
                this.sat1.position.copy(this.pathPoints[1]);
                this.sat1.lookAt(0,0,0);
                
                this.sat2.position.copy(this.pathPoints[3]);
                this.sat2.lookAt(0,0,0);

                this.pathLine.geometry.setFromPoints(this.pathPoints);
                this.pathLine.visible = this.ui.chkPath.checked;

                if(Math.random()>0.95) {
                    const p = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({color:0xffff00}));
                    p.userData = {seg: 0, t: 0};
                    p.position.copy(this.pathPoints[0]);
                    this.scene.add(p);
                    this.pulses.push(p);
                }

                for(let i=this.pulses.length-1; i>=0; i--) {
                    const p = this.pulses[i];
                    p.userData.t += 0.02;
                    if(p.userData.t >= 1) {
                        p.userData.t = 0;
                        p.userData.seg++;
                    }
                    if(p.userData.seg >= 4) {
                        this.scene.remove(p);
                        this.pulses.splice(i,1);
                    } else {
                        const start = this.pathPoints[p.userData.seg];
                        const end = this.pathPoints[p.userData.seg+1];
                        p.position.lerpVectors(start, end, p.userData.t);
                    }
                }

                if(this.cine) {
                    const el = (Date.now()-this.cStart)/1000; let txt="";
                    if(el<5) { 
                        txt="Sóng ngắn bắn lên và gặp Vệ tinh phản xạ (mô phỏng tầng điện ly)."; 
                        const targetPos = this.sat1.position.clone().add(new THREE.Vector3(0, 0, 30));
                        this.cam.position.lerp(targetPos, 0.05); 
                        this.ctrl.target.lerp(this.sat1.position, 0.05);
                    }
                    else if(el<10) { 
                        txt="Sóng bị phản xạ xuống mặt đất, rồi lại nảy lên gặp Vệ tinh thứ 2."; 
                        const targetPos = this.sat2.position.clone().add(new THREE.Vector3(0, 0, 30));
                        this.cam.position.lerp(targetPos, 0.05);
                        this.ctrl.target.lerp(this.sat2.position, 0.05);
                    }
                    else if(el<15) { 
                        txt="Quá trình này lặp lại giúp sóng truyền đi rất xa."; 
                        this.cam.position.lerp(new THREE.Vector3(0, 120, 50), 0.05); 
                        this.ctrl.target.lerp(new THREE.Vector3(0, 60, 0), 0.05);
                    }
                    else if(el<20) { 
                        txt="Đây là nguyên lý cơ bản của truyền thông vô tuyến sóng ngắn."; 
                    }
                    else { this.stopCine(); return; }
                    this.ui.sub.innerText=txt;
                } else this.ctrl.update();
            }
            loop() { requestAnimationFrame(()=>this.loop()); this.update(); this.ren.render(this.scene, this.cam); }
        }

        window.onload = () => { new WaveSim(); new AntSim(); new IonoSim(); }
    </script>
</body>
</html>
